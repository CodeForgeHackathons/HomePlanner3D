package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"ServerBTI/graph/assistant"
	"ServerBTI/graph/model"
	"ServerBTI/internal/models"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"strconv"
	"strings"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.User, error) {
	user_DataBase := &models.User{
		Login:    input.Login,
		Username: input.Username,
		Password: input.Password,
		Email:    input.Email,
		Birthday: input.Birthday,
	}
	user_graphql := &model.User{
		ID:       fmt.Sprintf("%d", user_DataBase.ID),
		Username: user_DataBase.Username,
		Email:    user_DataBase.Email,
		Login:    user_DataBase.Login,
	}

	if err := r.DB.Create(user_DataBase).Error; err != nil {
		return user_graphql, err
	}
	return user_graphql, nil
}

// CreatePlanningProject is the resolver for the createPlanningProject field.
func (r *mutationResolver) CreatePlanningProject(ctx context.Context, input model.PlanningProjectInput) (*model.PlanningProject, error) {
	inputJSON, err := json.Marshal(input)
	if err != nil {
		return nil, fmt.Errorf("ошибка подготовки данных для анализа: %w", err)
	}
	var decision string = "pending"
	aiAnalyze, err := assistant.AiAnalyze(string(inputJSON))
	if err == nil {
		if aiAnalyze.Decision != "" {
			decision = aiAnalyze.Decision
		}
	}
	db := r.DB

	// Пробуем получить userID из контекста (прокинут из заголовка X-User-Id)
	var userID int64 = 0
	if v := ctx.Value("userID"); v != nil {
		if s, ok := v.(string); ok {
			if parsed, err := strconv.ParseInt(strings.TrimSpace(s), 10, 64); err == nil && parsed > 0 {
				userID = parsed
			}
		}
	}
	// Если не удалось определить userID — используем существующего пользователя или создаём дефолтного
	if userID == 0 {
		var existing models.User
		if err := db.First(&existing).Error; err != nil {
			// Создаём дефолтного пользователя
			def := models.User{Login: "default", Password: "default", Username: "Default"}
			if err := db.Create(&def).Error; err != nil {
				log.Printf("failed to create default user: %v", err)
			} else {
				userID = def.ID
			}
		} else {
			userID = existing.ID
		}
	}

    project := models.PlanningProject{
        User_id:          userID,
        Status:            decision,
        Address:           input.Plan.Address,
        Area:              fmt.Sprintf("%f", input.Plan.Area),
        Source:            input.Plan.Source,
        LayoutType:        input.Plan.LayoutType,
        FamilyProfile:     input.Plan.FamilyProfile,
        Goal:              input.Plan.Goal,
        Prompt:            input.Plan.Prompt,
        CeilingHeight:     fmt.Sprintf("%f", input.Plan.CeilingHeight),
        FloorDelta:        fmt.Sprintf("%f", input.Plan.FloorDelta),
        RecognitionStatus: input.Plan.RecognitionStatus,
        ClientTimestamp:   func() string { if input.ClientTimestamp != nil { return *input.ClientTimestamp }; return "" }(),
    }

    // Если пришёл файл плана — сохраняем метаданные
    if input.Plan.File != nil {
        project.PlanFileName = input.Plan.File.Name
        project.PlanFileSize = fmt.Sprintf("%f", input.Plan.File.Size)
        project.PlanFileType = input.Plan.File.Type
        project.PlanFileContent = input.Plan.File.Content
    }

    if err := db.Create(&project).Error; err != nil {
        return nil, fmt.Errorf("ошибка сохранения проекта: %w", err)
    }

	// --- 4. Сохраняем комнаты ---
	for _, roomInput := range input.Geometry.Rooms {
		room := models.Room{
			ProjectID: project.ID,
			Name:      roomInput.Name,
			Height:    fmt.Sprintf("%f", roomInput.Height),
		}
		if err := db.Create(&room).Error; err != nil {
			return nil, err
		}

		for _, v := range roomInput.Vertices {
			vertex := models.RoomVertex{
				RoomID: room.ID,
				X:      fmt.Sprintf("%f", v.X),
				Y:      fmt.Sprintf("%f", v.Y),
			}
			if err := db.Create(&vertex).Error; err != nil {
				return nil, err
			}
		}
	}

	// --- 5. Сохраняем стены ---
	for _, wallInput := range input.Walls {
        wall := models.Wall{
            ProjectID:   project.ID,
            StartX:      fmt.Sprintf("%f", wallInput.Start.X),
            StartY:      fmt.Sprintf("%f", wallInput.Start.Y),
            EndX:        fmt.Sprintf("%f", wallInput.End.X),
            EndY:        fmt.Sprintf("%f", wallInput.End.Y),
            LoadBearing: wallInput.LoadBearing,
            Thickness:   fmt.Sprintf("%f", wallInput.Thickness),
            WallType:    func() string { if wallInput.WallType != nil { return *wallInput.WallType }; return "" }(),
        }
		if err := db.Create(&wall).Error; err != nil {
			return nil, err
		}
	}

	// --- 6. Сохраняем ограничения, если есть ---
	if input.Constraints != nil {
		constraints := models.Constraints{
			ProjectID:      project.ID,
			ForbiddenMoves: strings.Join(input.Constraints.ForbiddenMoves, ","),
			RegionRules:    strings.Join(input.Constraints.RegionRules, ","),
		}
		if err := db.Create(&constraints).Error; err != nil {
			return nil, err
		}
	}

	// --- 7. Формируем GraphQL ответ с геометрией/стенами/ограничениями ---
	gqlProject := ConvertDbProjectToGraph(&project)
	if input.Geometry != nil {
		rooms := make([]*model.Room, 0, len(input.Geometry.Rooms))
		for _, r := range input.Geometry.Rooms {
			verts := make([]*model.Vertex, 0, len(r.Vertices))
			for _, vv := range r.Vertices {
				verts = append(verts, &model.Vertex{X: vv.X, Y: vv.Y})
			}
			rid := ""
			if r.ID != nil {
				rid = *r.ID
			}
			rooms = append(rooms, &model.Room{
				ID:       rid,
				Name:     r.Name,
				Height:   r.Height,
				Vertices: verts,
			})
		}
		gqlProject.Geometry = &model.Geometry{Rooms: rooms}
	}
	if input.Walls != nil {
		walls := make([]*model.Wall, 0, len(input.Walls))
		for _, w := range input.Walls {
			wid := ""
			if w.ID != nil {
				wid = *w.ID
			}
			walls = append(walls, &model.Wall{
				ID:          wid,
				Start:       &model.WallEnd{X: w.Start.X, Y: w.Start.Y},
				End:         &model.WallEnd{X: w.End.X, Y: w.End.Y},
				LoadBearing: w.LoadBearing,
				Thickness:   w.Thickness,
				WallType:    w.WallType,
			})
		}
		gqlProject.Walls = walls
	}
	if input.Constraints != nil {
		gqlProject.Constraints = &model.Constraints{
			ForbiddenMoves: input.Constraints.ForbiddenMoves,
			RegionRules:    input.Constraints.RegionRules,
		}
	}
	return gqlProject, nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, id string) (*model.User, error) {
	uid, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user id")
	}

	var user_DataBase models.User

	if err := r.DB.First(&user_DataBase, uid).Error; err != nil {
		return nil, err
	}

	user_graphql := &model.User{
		Login:    user_DataBase.Login,
		Username: user_DataBase.Username,
		Email:    user_DataBase.Email,
	}

	return user_graphql, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
